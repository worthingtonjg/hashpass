<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hashpass</title>
<meta name="description" content="Generate strong, site-specific passwords locally from your master + domain. Nothing is sent anywhere." />
<style>
  :root { --fg:#111; --muted:#666; --bg:#fafafa; --card:#fff; --accent:#2563eb; --border:#e5e7eb; }
  * { box-sizing: border-box; }
  html, body { margin:0; padding:0; background:var(--bg); color:var(--fg); font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu; }
  .wrap { max-width:720px; margin:40px auto; padding:0 16px; }
  h1 { font-size:22px; margin:0 0 12px; }
  .card { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:16px; box-shadow:0 1px 2px rgba(0,0,0,.03); }
  .grid { display:grid; gap:12px; grid-template-columns: 1fr; }
  @media (min-width:720px){ .grid.two { grid-template-columns: 1fr 1fr; } .grid.three { grid-template-columns: 1fr 1fr 1fr; } }
  label { display:block; font-weight:600; margin-bottom:4px; }
  input[type=text], input[type=password], input[type=number], textarea {
    width:100%; padding:10px 12px; border:1px solid var(--border); border-radius:10px; background:#fff; font:inherit;
  }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .muted { color:var(--muted); font-size:12px; }
  button {
    appearance:none; border:none; background:var(--accent); color:#fff; padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:600;
  }
  button.secondary { background:#eee; color:#111; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .result { display:flex; gap:8px; align-items:center; }
  .note { margin-top:10px; font-size:12px; color:var(--muted); }
  .bad { color:#b91c1c; }
  .good { color:#047857; }
</style>
</head>
<body>
<div class="wrap">
  <h1>Deterministic Site Password</h1>
  <div class="card">
    <div class="grid">
      <div>
        <label for="domain">Domain <span class="muted">(auto from your URL is best)</span></label>
        <input id="domain" type="text" placeholder="example.com">
      </div>
      <div>
        <label for="username">Username (optional)</label>
        <input id="username" type="text" placeholder="you@domain.com">
      </div>
      <div>
        <label for="counter">Counter</label>
        <input id="counter" type="number" min="1" value="1">
      </div>
      <div>
        <label for="master">Master Password</label>
        <input id="master" type="password" autocomplete="off" placeholder="never stored">
      </div>
    </div>

    <div class="grid two" style="margin-top:12px">
      <div>
        <label for="length">Length</label>
        <input id="length" type="number" min="8" max="64" value="18">
      </div>
      <div>
        <label for="iters">PBKDF2 Iterations</label>
        <input id="iters" type="number" min="100000" step="10000" value="200000">
      </div>
    </div>

    <div class="row" style="margin:12px 0">
      <label class="row"><input id="reqLower" type="checkbox" checked> lower</label>
      <label class="row"><input id="reqUpper" type="checkbox" checked> upper</label>
      <label class="row"><input id="reqDigit" type="checkbox" checked> digit</label>
      <label class="row"><input id="reqSymbol" type="checkbox" checked> symbol</label>
    </div>

    <div>
      <label for="allowed">Allowed Characters</label>
      <input id="allowed" type="text" class="mono"
             value="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-_=+[]{};:,.?/">
    </div>

    <div class="row" style="margin-top:14px">
      <button id="generate">Generate</button>
      <button id="copy" class="secondary">Copy</button>
      <button id="save" class="secondary" title="Save non-secret prefs for this domain">Save Site Prefs</button>
      <span id="status" class="muted"></span>
    </div>

    <div class="result" style="margin-top:12px">
      <label for="pw" style="margin:0">Result</label>
      <input id="pw" type="text" class="mono" readonly>
    </div>

    <div class="note">
      All generation happens locally with WebCrypto (PBKDF2/SHA-256). We never store your master.  
      You can optionally save per-site non-secret settings (length, counter, etc.) in your browserâ€™s localStorage.
    </div>
  </div>

  <p class="note" style="margin-top:10px">
    Tip: bind to the effective domain (e.g., <code>example.co.uk</code>). If a site rejects a password, bump <b>Counter</b>.
  </p>
</div>

<script>
// ---------- Utilities ----------
const $ = (sel) => document.querySelector(sel);

function normalizeDomain(input) {
  let s = (input || "").trim().toLowerCase();
  try {
    if (!s.includes("://")) s = "https://" + s;
    const u = new URL(s);
    let h = u.hostname.toLowerCase();
    if (h.startsWith("www.")) h = h.slice(4);
    return h;
  } catch { return (input || "").trim().toLowerCase(); }
}

function textEncoder() { return new TextEncoder(); }

// PBKDF2/SHA-256 via WebCrypto
async function pbkdf2(master, saltText, iterations, byteLen) {
  const enc = textEncoder();
  const keyMaterial = await crypto.subtle.importKey(
    "raw", enc.encode(master), { name: "PBKDF2" }, false, ["deriveBits"]
  );
  const bits = await crypto.subtle.deriveBits(
    { name: "PBKDF2", hash: "SHA-256", iterations, salt: enc.encode(saltText) },
    keyMaterial, byteLen * 8
  );
  return new Uint8Array(bits);
}

// Deterministic sampling without modulo bias
function pickFromBytes(bytes, allowed, countNeeded) {
  const out = new Array(countNeeded);
  let pos = 0;
  const L = allowed.length;
  const threshold = 256 - (256 % L);
  for (let i = 0; i < countNeeded; i++) {
    while (true) {
      if (pos >= bytes.length) throw new Error("not enough bytes");
      const b = bytes[pos++];
      if (b < threshold) { out[i] = allowed[b % L]; break; }
    }
  }
  return { chars: out, pos };
}

// Deterministically pick an index (more bytes if needed)
function pickIndex(bytes, posRef, mod) {
  const threshold = 256 - (256 % mod);
  while (true) {
    if (posRef.pos >= bytes.length) throw new Error("not enough bytes");
    const b = bytes[posRef.pos++];
    if (b < threshold) return b % mod;
  }
}

// Enforce character class requirements by replacing positions deterministically
function enforceCategories(chars, allowed, reqs, bytes, posRef) {
  const arr = chars;
  const hasLower  = arr.some(c => /[a-z]/.test(c));
  const hasUpper  = arr.some(c => /[A-Z]/.test(c));
  const hasDigit  = arr.some(c => /[0-9]/.test(c));
  const symbolSet = [...allowed].filter(c => !/[a-zA-Z0-9]/.test(c));
  const hasSymbol = arr.some(c => !/[a-zA-Z0-9]/.test(c));

  function forceOne(poolStr) {
    if (!poolStr || poolStr.length === 0) return;
    const i = pickIndex(bytes, posRef, arr.length);
    const j = pickIndex(bytes, posRef, poolStr.length);
    arr[i] = poolStr[j];
  }

  if (reqs.lower && !hasLower)  forceOne("abcdefghijklmnopqrstuvwxyz");
  if (reqs.upper && !hasUpper)  forceOne("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
  if (reqs.digit && !hasDigit)  forceOne("0123456789");
  if (reqs.symbol && !hasSymbol && symbolSet.length) forceOne(symbolSet.join(""));
  return arr;
}

async function generatePassword(opts) {
  const {
    master, domain, username, counter, length,
    iterations, allowed, reqLower, reqUpper, reqDigit, reqSymbol
  } = opts;

  if (!master) throw new Error("Master required");
  if (!domain) throw new Error("Domain required");
  if (!allowed) throw new Error("Allowed charset empty");
  if (length < 8) throw new Error("Length too short");

  const normDomain = normalizeDomain(domain);
  const salt = `PWGEN:v1|site:${normDomain}|user:${username || ""}|ctr:${counter || 1}`;

  // Derive more bytes than needed to avoid refill complexity
  const need = length + 64;
  const dk = await pbkdf2(master, salt, iterations, need);

  // Base characters
  const { chars, pos } = pickFromBytes(dk, allowed, length);
  const posRef = { pos };

  // Enforce categories
  const enforced = enforceCategories(
    chars, allowed,
    { lower: reqLower, upper: reqUpper, digit: reqDigit, symbol: reqSymbol },
    dk, posRef
  );

  return enforced.join("");
}

// ---------- UI wiring ----------
async function loadPrefsFor(domain) {
  const key = "prefs:" + normalizeDomain(domain || "");
  try {
    const v = localStorage.getItem(key);
    return v ? JSON.parse(v) : null;
  } catch { return null; }
}
function savePrefsFor(domain, prefs) {
  const key = "prefs:" + normalizeDomain(domain || "");
  localStorage.setItem(key, JSON.stringify(prefs));
}

async function populateFromPrefs() {
  const d = normalizeDomain($("#domain").value);
  if (!d) return;
  const p = await loadPrefsFor(d);
  if (!p) return;
  if (p.username) $("#username").value = p.username;
  if (p.counter)  $("#counter").value  = p.counter;
  if (p.length)   $("#length").value   = p.length;
  if (p.iters)    $("#iters").value    = p.iters;
  if (p.allowed)  $("#allowed").value  = p.allowed;
  if ("reqLower" in p)  $("#reqLower").checked  = !!p.reqLower;
  if ("reqUpper" in p)  $("#reqUpper").checked  = !!p.reqUpper;
  if ("reqDigit" in p)  $("#reqDigit").checked  = !!p.reqDigit;
  if ("reqSymbol" in p) $("#reqSymbol").checked = !!p.reqSymbol;
}

async function onGenerate() {
  $("#status").textContent = "";
  try {
    const pw = await generatePassword({
      master: $("#master").value,
      domain: $("#domain").value,
      username: $("#username").value.trim(),
      counter: parseInt($("#counter").value || "1", 10),
      length: Math.max(8, Math.min(64, parseInt($("#length").value || "18", 10))),
      iterations: Math.max(100000, parseInt($("#iters").value || "200000", 10)),
      allowed: $("#allowed").value,
      reqLower: $("#reqLower").checked,
      reqUpper: $("#reqUpper").checked,
      reqDigit: $("#reqDigit").checked,
      reqSymbol: $("#reqSymbol").checked
    });
    $("#pw").value = pw;
    // wipe master input right after generation (optional, but safer)
    $("#master").value = "";
    $("#status").textContent = "Generated";
  } catch (e) {
    $("#status").textContent = e.message;
  }
}

async function onCopy() {
  const v = $("#pw").value;
  if (!v) { $("#status").textContent = "Nothing to copy"; return; }
  try { await navigator.clipboard.writeText(v); $("#status").textContent = "Copied"; }
  catch { $("#status").textContent = "Copy failed"; }
}

function onSavePrefs() {
  const d = $("#domain").value;
  if (!d) { $("#status").textContent = "Enter a domain first"; return; }
  const prefs = {
    username: $("#username").value.trim(),
    counter: parseInt($("#counter").value || "1", 10),
    length: parseInt($("#length").value || "18", 10),
    iters: parseInt($("#iters").value || "200000", 10),
    allowed: $("#allowed").value,
    reqLower: $("#reqLower").checked,
    reqUpper: $("#reqUpper").checked,
    reqDigit: $("#reqDigit").checked,
    reqSymbol: $("#reqSymbol").checked
  };
  savePrefsFor(d, prefs);
  $("#status").textContent = "Prefs saved locally";
}

document.addEventListener("DOMContentLoaded", () => {
  populateFromPrefs();

  $("#generate").addEventListener("click", onGenerate);
  $("#copy").addEventListener("click", onCopy);
  $("#save").addEventListener("click", onSavePrefs);

  $("#domain").addEventListener("change", populateFromPrefs);
});
</script>
</body>
</html>
